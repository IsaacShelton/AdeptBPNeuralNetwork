
import 'sys/cmath.adept'
import 'sys/cstdio.adept'
import 'sys/cstdlib.adept'
import 'sys/cstring.adept'

struct Neuron (
    output double,
    connections *Synapse,
    connections_length usize
)

struct Synapse (
    delta double,
    weight double
)

struct NeuralLayer (neurons *Neuron, length usize)
struct NeuralNetwork (layers *NeuralLayer, length usize)
struct NeuralBlueprint (neuron_count *usize, length usize, capacity usize)

func normalizedRandom() double {
    return cast double rand() / cast double RAND_MAX
}

// ------------------- NeuralBlueprint -------------------

func create(this *NeuralBlueprint) void {
    this.neuron_count = malloc(sizeof *usize * 4)
    this.length = 0; this.capacity = 4
}

func addLayer(this *NeuralBlueprint, count usize) void {
    if this.length == this.capacity {
        this.capacity *= 2
        new_neuron_count *usize = malloc(sizeof *usize * this.capacity)
        memcpy(new_neuron_count, this.neuron_count, sizeof *usize * this.length)
        free(this.neuron_count)
        this.neuron_count = new_neuron_count
    }

    this.neuron_count[this.length] = count
    this.length += 1
}

func free(this *NeuralBlueprint) void {
    free(this.neuron_count)
}

// ------------------- NeuralNetwork-------------------

func create(this *NeuralNetwork, blueprint *NeuralBlueprint) void {
    this.length = blueprint.length
    this.layers = malloc(sizeof NeuralLayer * this.length)

    i usize = 0; while i != this.length {
        layerOutputCount usize = 0
        if i != this.length, layerOutputCount = blueprint.neuron_count[i] + 1
        this.layers[i].createTheLayer(blueprint.neuron_count[i] + 1, layerOutputCount); i += 1
    }
}

func feedForward(this *NeuralNetwork) void {

}

func backPropagate(this *NeuralNetwork) void {

}

func free(this *NeuralNetwork) void {
    i usize = 0; while i != this.length, this.layers[i].free(); i += 1
    free(this.layers)
}

// ------------------- NeuralLayer-------------------

func createTheLayer(this *NeuralLayer, neuron_count usize, output_count usize) void {
    this.length = neuron_count
    this.neurons = malloc(sizeof Neuron * this.length)

    i usize = 0; while i != this.length {
        this.neurons[i].create(output_count); i += 1
    }
}

func free(this *NeuralLayer) void {
    i usize = 0; while i != this.length, this.neurons[i].free(); i += 1
    free(this.neurons)
}

// ------------------- Synapse-------------------

func create(this *Synapse, delta double, weight double) void {
    this.delta = delta; this.weight = weight
}

func create(this *Synapse) void {
    this.delta = 0.0
    this.weight = normalizedRandom()
}

// ------------------- Neuron-------------------

func create(this *Neuron, outputCount usize) void {
    this.connections_length = outputCount
    this.connections = malloc(sizeof Synapse * outputCount)

    i usize = 0; while i != outputCount {
        this.connections[i].create(); i += 1
    }
}

func free(this *Neuron) void {
    free(this.connections)
}
